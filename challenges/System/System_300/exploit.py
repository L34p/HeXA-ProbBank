'''
char user_password[256];
char real_password[256];
~
scanf("%256s", user_password);
~
if(!strncmp(user_password, real_password, strlen(real_password))){
~


array size of user_password is 256 and scanf read 256 byte. (%256s)

Then, where is null? string have to end with null...

Actually, a terminating null character is automatically added at the end of input by scanf.
( http://www.cplusplus.com/reference/cstdio/scanf/ )

So if we input more than 256 byte, one byte is overflowed and this one byte is null! (automatically added by scanf %s functionality)

Also variable locations in memeory are [ user_password[256] ][ real_password[256] ]

Therefore, One byte null is written in real_password[0].


Then what happen in "strncmp(user_password, real_password, strlen(real_password))" 

strlen(real_password) return 0 since real_password[0] is null!

return value of strncmp(user_password, real_password, 0) is always zero, it means that contents of both string is equal.

Finally we pass authentication and get the flag :)

'''
print "A"*256

'''
(python exploit.py; cat) | ./auth
password: do not bruteforce...
Great! Here is flag :)
0ff-by-0n3 0v3rflOw can be d4ngerous!
'''
